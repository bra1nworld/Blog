# 快速选择

```typescript
/*
leecode:
215.数组中的第 K 个最大元素（中等）
*/
```

快速选择算法是一个非常经典的算法，和快速排序算法是亲兄弟。

原始题目很简单，给你输入一个无序的数组 nums 和一个正整数 k，让你计算 nums 中第 k 大的元素。

那你肯定说，给 nums 数组排个序，然后取第 k 个元素，也就是 nums[k-1]，不就行了吗？

当然可以，但是排序时间复杂度是 O(NlogN)，其中 N 表示数组 nums 的长度。

我们就想要第 k 大的元素，却给整个数组排序，有点杀鸡用牛刀的感觉，所以这里就有一些小技巧了，可以把时间复杂度降低到 O(NlogK) 甚至是 O(N)

一种是二叉堆（优先队列）的解法，另一种就是标题说到的快速选择算法（Quick Select）

## 二叉堆

```typescript
function findKthLargest(nums: number[], k: number) {
  // 小堆顶，堆顶是最小元素
  // PriorityQueue    [todo]
  const pq = new PriorityQueue();
  for (const n of nums) {
    pq.push(e);
    // 堆中元素多余k个时，删除堆顶元素
    if (pq.length > k) {
      pq.shift();
    }
  }

  // pq中剩下的是nums中k个最大元素
  // 堆顶是最小的那个，即第k个最大元素
  return pq[0];
}
```

可以把小顶堆 pq 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 k 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 k 个最大元素嘛。当 nums 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 k 个元素，而堆顶元素是堆中最小的元素，也就是「第 k 个最大的元素」。

二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 k，所以插入和删除元素的复杂度是 O(logK)，再套一层 for 循环，总的时间复杂度就是 O(NlogK)。空间复杂度很显然就是二叉堆的大小，为 O(K)。

## 快速选择

快速选择算法比较巧妙，时间复杂度更低，是快速排序的简化版，一定要熟悉思路。

快速排序的逻辑是，若要对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。

**索引 p 左侧的元素都比 nums[p] 小，右侧的元素都比 nums[p] 大，意味着这个元素已经放到了正确的位置上**，回顾快速排序的逻辑，递归调用会把 nums[p] 之外的元素也都放到正确的位置上，从而实现整个数组排序，这就是快速排序的核心逻辑。

partition 函数的实现：

```typescript
function partition(nums: number[], lo: number, hi: number) {
  if (lo == hi) return lo;
  // 将nums[lo]作为默认分界点pivot
  let privot = nums[lo];
  // j=hi+1 因为while中会先执行 --
  let i = lo,
    j = hi + 1;

  while (true) {
    // 保证nums[lo..i]都小于pivot
    while (nums[++i] < pivot) {
      if (i == hi) break;
    }
    // 保证nums[j..hi]都大于pivot
    while (nums[--j] > pivot) {
      if (j == lo) break;
    }

    if (i >= j) break;
    // 走到这里一定有：
    // nums[i]>pivot && nums[j]<pivot
    // 所以需要交换nums[i]和nums[j]
    // 保证nums[lo..i] < pivot < nums[j..hi]
    [nums[i], nums[j]] = [nums[j], nums[i]];
    return j;
  }
}
```

寻找第 k 大的元素，和快速排序有什么关系？

注意这段代码：

```typescript
let p = partition(nums, lo, hi);
```

partition 函数会将 nums[p]排到正确的位置，使得 nums[lo..p-1] < nums[p] < num[p+1..hi]

**那么我们可以把 p 和 k 进行比较，如果 p < k 说明第 k 大的元素在 nums[p+1..hi]中，如果 p > k 说明第 k 大的元素在 nums[lo ..p-1]中**。

题目要求的是「第 k 个最大元素」，这个元素其实就是 nums 升序排序后「索引」为 len(nums) - k 的这个元素。

```typescript
function findKthLargest(nums: number[], k: number) {
  let lo = 0,
    hi = nums.length - 1;

  // 转换索引
  k = nums.length - k;
  while (lo <= hi) {
    // 在nums[lo..hi]中选一个分界点
    let p = partitioin(nums, lo, hi);
    if (p < k) {
      // 第 k 大的元素在 nums[p+1..hi] 中
      lo = p + 1;
    } else if (p > k) {
      // 第 k 大的元素在 nums[lo..p-1] 中
      hi = p - 1;
    } else {
      return nums[p];
    }
  }
  return -1;
}
```

这个代码框架其实非常像我们前文 二分搜索框架 的代码，这也是这个算法高效的原因，但是时间复杂度为什么是 O(N) 呢？按理说类似二分搜索的逻辑，时间复杂度应该一定会出现对数才对呀？

其实这个 O(N) 的时间复杂度是个均摊复杂度，因为我们的 partition 函数中需要利用 双指针技巧 遍历 nums[lo..hi]，那么总共遍历了多少元素呢？

最好情况下，每次 p 都恰好是正中间 (lo + hi) / 2，那么遍历的元素总数就是：

N + N/2 + N/4 + N/8 + ... + 1

这就是等比数列求和公式嘛，求个极限就等于 2N，所以遍历元素个数为 2N，时间复杂度为 O(N)。

但我们其实不能保证每次 p 都是正中间的索引的，最坏情况下 p 一直都是 lo + 1 或者一直都是 hi - 1，遍历的元素总数就是：

N + (N - 1) + (N - 2) + ... + 1

这就是个等差数列求和，时间复杂度会退化到 O(N^2)，为了尽可能防止极端情况发生，我们需要在算法开始的时候对 nums 数组来一次随机打乱：

```typescript
function findKthLargest(nums: number[], k: number) {
  // 首先随机打乱数组
  shuffle(nums);

  let lo = 0,
    hi = nums.length - 1;

  // 转换索引
  k = nums.length - k;
  while (lo <= hi) {
    // ...
  }
  return -1;
}

function shuffle(nums: number[]) {
  for (let i = 0; i < nums.length; i++) {
    const element = nums[i];
    const ran = (Math.floor(Math.random() * i)[(nums[i], nums[ran])] = [
      nums[ran],
      nums[i],
    ]);
  }
}
```
